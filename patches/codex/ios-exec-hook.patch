diff --git a/codex-rs/core/src/exec.rs b/codex-rs/core/src/exec.rs
index 1e0e59d4e..1debd935d 100644
--- a/codex-rs/core/src/exec.rs
+++ b/codex-rs/core/src/exec.rs
@@ -36,6 +36,21 @@ use crate::text_encoding::bytes_to_string_smart;
 use codex_network_proxy::NetworkProxy;
 use codex_utils_pty::process_group::kill_child_process_group;
 
+#[cfg(target_os = "ios")]
+use std::sync::OnceLock;
+
+/// Pluggable executor for platforms that cannot fork/exec (e.g. iOS).
+#[cfg(target_os = "ios")]
+pub(crate) static IOS_EXEC_HOOK: OnceLock<
+    fn(&[String], &Path, &HashMap<String, String>) -> (i32, Vec<u8>),
+> = OnceLock::new();
+
+/// Register the iOS exec hook before starting the server.
+#[cfg(target_os = "ios")]
+pub fn set_ios_exec_hook(f: fn(&[String], &Path, &HashMap<String, String>) -> (i32, Vec<u8>)) {
+    let _ = IOS_EXEC_HOOK.set(f);
+}
+
 pub const DEFAULT_EXEC_COMMAND_TIMEOUT_MS: u64 = 10_000;
 
 // Hardcode these since it does not seem worth including the libc crate just
@@ -713,28 +728,60 @@ async fn exec(
         network.apply_to_env(&mut env);
     }
 
-    let (program, args) = command.split_first().ok_or_else(|| {
-        CodexErr::Io(io::Error::new(
-            io::ErrorKind::InvalidInput,
-            "command args are empty",
-        ))
-    })?;
-    let arg0_ref = arg0.as_deref();
-    let child = spawn_child_async(SpawnChildRequest {
-        program: PathBuf::from(program),
-        args: args.into(),
-        arg0: arg0_ref,
-        cwd,
-        sandbox_policy,
-        // The environment already has attempt-scoped proxy settings from
-        // apply_to_env_for_attempt above. Passing network here would reapply
-        // non-attempt proxy vars and drop attempt correlation metadata.
-        network: None,
-        stdio_policy: StdioPolicy::RedirectForShellTool,
-        env,
-    })
-    .await?;
-    consume_truncated_output(child, expiration, stdout_stream).await
+    #[cfg(target_os = "ios")]
+    {
+        let (code, data) = IOS_EXEC_HOOK
+            .get()
+            .map(|f| f(&command, &cwd, &env))
+            .unwrap_or_else(|| {
+                (
+                    -1,
+                    b"shell exec unavailable: no iOS exec hook registered\n".to_vec(),
+                )
+            });
+        return Ok(RawExecToolCallOutput {
+            exit_status: synthetic_exit_status(code),
+            stdout: StreamOutput {
+                text: data.clone(),
+                truncated_after_lines: None,
+            },
+            stderr: StreamOutput {
+                text: Vec::new(),
+                truncated_after_lines: None,
+            },
+            aggregated_output: StreamOutput {
+                text: data,
+                truncated_after_lines: None,
+            },
+            timed_out: false,
+        });
+    }
+
+    #[cfg(not(target_os = "ios"))]
+    {
+        let (program, args) = command.split_first().ok_or_else(|| {
+            CodexErr::Io(io::Error::new(
+                io::ErrorKind::InvalidInput,
+                "command args are empty",
+            ))
+        })?;
+        let arg0_ref = arg0.as_deref();
+        let child = spawn_child_async(SpawnChildRequest {
+            program: PathBuf::from(program),
+            args: args.into(),
+            arg0: arg0_ref,
+            cwd,
+            sandbox_policy,
+            // The environment already has attempt-scoped proxy settings from
+            // apply_to_env_for_attempt above. Passing network here would reapply
+            // non-attempt proxy vars and drop attempt correlation metadata.
+            network: None,
+            stdio_policy: StdioPolicy::RedirectForShellTool,
+            env,
+        })
+        .await?;
+        consume_truncated_output(child, expiration, stdout_stream).await
+    }
 }
 
 /// Consumes the output of a child process, truncating it so it is suitable for
diff --git a/codex-rs/core/src/unified_exec/process_manager.rs b/codex-rs/core/src/unified_exec/process_manager.rs
index 694531646..77e5d8406 100644
--- a/codex-rs/core/src/unified_exec/process_manager.rs
+++ b/codex-rs/core/src/unified_exec/process_manager.rs
@@ -163,6 +163,12 @@ impl UnifiedExecProcessManager {
             .workdir
             .clone()
             .unwrap_or_else(|| context.turn.cwd.clone());
+
+        #[cfg(target_os = "ios")]
+        {
+            return self.exec_command_ios(&request, cwd, context).await;
+        }
+
         let process = self
             .open_session_with_sandbox(&request, cwd.clone(), context)
             .await;
@@ -294,6 +300,85 @@ impl UnifiedExecProcessManager {
         Ok(response)
     }
 
+    #[cfg(target_os = "ios")]
+    async fn exec_command_ios(
+        &self,
+        request: &ExecCommandRequest,
+        cwd: PathBuf,
+        context: &UnifiedExecContext,
+    ) -> Result<UnifiedExecResponse, UnifiedExecError> {
+        use crate::exec::IOS_EXEC_HOOK;
+        use crate::exec_env::create_env;
+
+        let env = create_env(
+            &context.turn.shell_environment_policy,
+            Some(context.session.conversation_id),
+        );
+
+        let event_ctx = ToolEventCtx::new(
+            context.session.as_ref(),
+            context.turn.as_ref(),
+            &context.call_id,
+            None,
+        );
+        let emitter = ToolEmitter::unified_exec(
+            &request.command,
+            cwd.clone(),
+            ExecCommandSource::UnifiedExecStartup,
+            Some(request.process_id.clone()),
+        );
+        emitter.emit(event_ctx, ToolEventStage::Begin).await;
+
+        let start = Instant::now();
+        let (exit_code, raw_output) = tokio::task::spawn_blocking({
+            let command = request.command.clone();
+            let cwd = cwd.clone();
+            move || {
+                IOS_EXEC_HOOK
+                    .get()
+                    .map(|f| f(&command, &cwd, &env))
+                    .unwrap_or((-1, b"no iOS exec hook registered\n".to_vec()))
+            }
+        })
+        .await
+        .unwrap_or((-1, b"spawn_blocking panicked\n".to_vec()));
+        let wall_time = Instant::now().saturating_duration_since(start);
+
+        let text = String::from_utf8_lossy(&raw_output).to_string();
+        let max_tokens = resolve_max_tokens(request.max_output_tokens);
+        let output = formatted_truncate_text(&text, TruncationPolicy::Tokens(max_tokens));
+
+        let transcript = Arc::new(tokio::sync::Mutex::new(HeadTailBuffer::default()));
+        emit_exec_end_for_unified_exec(
+            Arc::clone(&context.session),
+            Arc::clone(&context.turn),
+            context.call_id.clone(),
+            request.command.clone(),
+            cwd,
+            Some(request.process_id.clone()),
+            transcript,
+            output.clone(),
+            exit_code,
+            wall_time,
+        )
+        .await;
+
+        self.release_process_id(&request.process_id).await;
+
+        let original_token_count = approx_token_count(&text);
+        Ok(UnifiedExecResponse {
+            event_call_id: context.call_id.clone(),
+            chunk_id: generate_chunk_id(),
+            wall_time,
+            output,
+            raw_output,
+            process_id: None,
+            exit_code: Some(exit_code),
+            original_token_count: Some(original_token_count),
+            session_command: Some(request.command.clone()),
+        })
+    }
+
     pub(crate) async fn write_stdin(
         &self,
         request: WriteStdinRequest<'_>,
